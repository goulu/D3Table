{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/clusterize.js/clusterize.js","webpack:///(webpack)/buildin/harmony-module.js","webpack:///./table.js","webpack:///external \"d3\""],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;AACA,gCAAgC;;AAEhC,CAAC;AACD,MAAM,IAA4B;AAClC,OAAO,EAC0B;AACjC,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;AACD,C;;;;;;;;;;;AC7XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEwC;AAChB;;AAExB,mCAAmC,wDAAU;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAS;AAC7B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;;AAGT;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2DAA2D;AAC3D,aAAa;AACb,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,yCAAS;AACjB;AACA;AACA,wBAAwB;AACxB;;AAEA,gCAAgC;AAChC,gCAAgC;AAChC;;AAEA,0CAA0C,wBAAwB;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,SAAS;;AAET,mCAAmC;AACnC;AACA,SAAS;AACT,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,wCAAQ;AAC5B,oDAAoD;AACpD;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,oDAAoB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;;AAGA;AACA;AACA,4CACc;AACd;AACA;AACA,eAAe,yCAAS;AACxB;AACA,4CACc;AACd;AACA;AACA;AACA,eAAe,yCAAS;AACxB;;AAEA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,SAAS;AACT;;AAEA,eAAe;AACf;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA,KAAK;AACL;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,C;;;;;;;;;;;;AClhBA,oB","file":"table.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./table.js\");\n","/* Clusterize.js - v0.19.0 - 2020-05-18\r\n http://NeXTs.github.com/Clusterize.js/\r\n Copyright (c) 2015 Denis Lukov; Licensed GPLv3 */\r\n\r\n;(function (name, definition) {\r\n  if (typeof module != 'undefined') module.exports = definition();\r\n  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition);\r\n  else this[name] = definition();\r\n}('Clusterize', function () {\r\n  \"use strict\"\r\n\r\n  // detect ie9 and lower\r\n  // https://gist.github.com/padolsey/527683#comment-786682\r\n  var ie = (function(){\r\n    for( var v = 3,\r\n             el = document.createElement('b'),\r\n             all = el.all || [];\r\n         el.innerHTML = '<!--[if gt IE ' + (++v) + ']><i><![endif]-->',\r\n         all[0];\r\n       ){}\r\n    return v > 4 ? v : document.documentMode;\r\n  }()),\r\n  is_mac = navigator.platform.toLowerCase().indexOf('mac') + 1;\r\n  \r\n  var Clusterize = function(data) {\r\n    if( ! (this instanceof Clusterize))\r\n      return new Clusterize(data);\r\n    var self = this;\r\n\r\n    var defaults = {\r\n      rows_in_block: 50,\r\n      blocks_in_cluster: 4,\r\n      tag: null,\r\n      show_no_data_row: true,\r\n      no_data_class: 'clusterize-no-data',\r\n      no_data_text: 'No data',\r\n      keep_parity: true,\r\n      callbacks: {}\r\n    }\r\n\r\n    // public parameters\r\n    self.options = {};\r\n    var options = ['rows_in_block', 'blocks_in_cluster', 'show_no_data_row', 'no_data_class', 'no_data_text', 'keep_parity', 'tag', 'callbacks'];\r\n    for(var i = 0, option; option = options[i]; i++) {\r\n      self.options[option] = typeof data[option] != 'undefined' && data[option] != null\r\n        ? data[option]\r\n        : defaults[option];\r\n    }\r\n\r\n    var elems = ['scroll', 'content'];\r\n    for(var i = 0, elem; elem = elems[i]; i++) {\r\n      self[elem + '_elem'] = data[elem + 'Id']\r\n        ? document.getElementById(data[elem + 'Id'])\r\n        : data[elem + 'Elem'];\r\n      if( ! self[elem + '_elem'])\r\n        throw new Error(\"Error! Could not find \" + elem + \" element\");\r\n    }\r\n\r\n    // tabindex forces the browser to keep focus on the scrolling list, fixes #11\r\n    if( ! self.content_elem.hasAttribute('tabindex'))\r\n      self.content_elem.setAttribute('tabindex', 0);\r\n\r\n    // private parameters\r\n\r\n    var nrows = (data.nrows !== undefined) ? data.nrows : 0\r\n    var frow = function (i) {\r\n      return ''\r\n    }; // function that returns i-th row as HTML text\r\n\r\n    var _rows = function () {\r\n      // private function that rebuilds the array for append+prepend+destroy\r\n      var arr = Array.apply(null, Array(nrows));\r\n      arr = arr.map(function (x, i) {\r\n        return frow(i)\r\n      });\r\n      return arr\r\n    }\r\n\r\n    var add = function (new_rows, where = \"append\") {\r\n      if (isArray(new_rows)) { // the \"classic\" case\r\n        var arr = (where == 'append')\r\n          ? _rows().concat(new_rows)\r\n          : new_rows.concat(_rows());\r\n        frow = function (i) {\r\n          return arr[i]\r\n        }\r\n        nrows += new_rows.length;\r\n      }\r\n      else if (isFunction(new_rows)) { // rows defined by a function\r\n        frow = new_rows;\r\n        // nrows should be assigned separately\r\n      }\r\n    }\r\n\r\n    if (data.rows !== undefined) {\r\n      add(data.rows);\r\n    }\r\n    else {\r\n      add(this.fetchMarkup());\r\n    }\r\n\r\n    var cache = {},\r\n      scroll_top = self.scroll_elem.scrollTop;\r\n\r\n    // append initial data\r\n    self.insertToDOM(frow, nrows, cache);\r\n\r\n    // restore the scroll position\r\n    self.scroll_elem.scrollTop = scroll_top;\r\n\r\n    // adding scroll handler\r\n    var last_cluster = false,\r\n    scroll_debounce = 0,\r\n    pointer_events_set = false,\r\n    scrollEv = function() {\r\n      // fixes scrolling issue on Mac #3\r\n      if (is_mac) {\r\n          if( ! pointer_events_set) self.content_elem.style.pointerEvents = 'none';\r\n          pointer_events_set = true;\r\n          clearTimeout(scroll_debounce);\r\n          scroll_debounce = setTimeout(function () {\r\n              self.content_elem.style.pointerEvents = 'auto';\r\n              pointer_events_set = false;\r\n          }, 50);\r\n        }\r\n        if (last_cluster != (last_cluster = self.getClusterNum()))\r\n          self.insertToDOM(frow, nrows, cache);\r\n        if (self.options.callbacks.scrollingProgress)\r\n          self.options.callbacks.scrollingProgress(self.getScrollProgress());\r\n      },\r\n      resize_debounce = 0,\r\n      resizeEv = function () {\r\n        clearTimeout(resize_debounce);\r\n        resize_debounce = setTimeout(self.refresh, 100);\r\n      }\r\n    on('scroll', self.scroll_elem, scrollEv);\r\n    on('resize', window, resizeEv);\r\n\r\n    // public methods\r\n    self.destroy = function (clean) {\r\n      off('scroll', self.scroll_elem, scrollEv);\r\n      off('resize', window, resizeEv);\r\n      self.html((clean ? self.generateEmptyRow() : _rows()).join(''));\r\n    }\r\n    self.refresh = function (force) {\r\n      if (self.getRowsHeight(nrows) || force) self.update(frow,nrows);\r\n    }\r\n    self.update = function (new_rows, new_nrows = 0) {\r\n      // a new_nrows should be specified if new_rows is a function, otherwise it's recalculated\r\n      nrows = new_nrows;\r\n      add(new_rows);\r\n      var scroll_top = self.scroll_elem.scrollTop;\r\n      // fixes #39\r\n      if (nrows * self.options.item_height < scroll_top) {\r\n        self.scroll_elem.scrollTop = 0;\r\n        last_cluster = 0;\r\n      }\r\n      self.insertToDOM(frow, nrows, cache);\r\n      self.scroll_elem.scrollTop = scroll_top;\r\n    }\r\n    self.clear = function () {\r\n      self.update([],0);\r\n    }\r\n    self.getRowsAmount = function () {\r\n      return nrows;\r\n    }\r\n    self.getScrollProgress = function () {\r\n      return this.options.scroll_top / (nrows * this.options.item_height) * 100 || 0;\r\n    }\r\n\r\n    self.append = function (rows) {\r\n      add(rows, 'append',);\r\n      self.insertToDOM(frow, nrows, cache);\r\n    }\r\n    self.prepend = function (rows) {\r\n      add(rows, 'prepend');\r\n      self.insertToDOM(frow, nrows, cache);\r\n    }\r\n  };\r\n\r\n  Clusterize.prototype = {\r\n    constructor: Clusterize,\r\n    // fetch existing markup\r\n    fetchMarkup: function () {\r\n      var rows = [], rows_nodes = this.getChildNodes(this.content_elem);\r\n      while (rows_nodes.length) {\r\n        rows.push(rows_nodes.shift().outerHTML);\r\n      }\r\n      return rows;\r\n    },\r\n    // get tag name, content tag name, tag height, calc cluster height\r\n    exploreEnvironment: function (frow, nrows, cache) {\r\n      var opts = this.options;\r\n      opts.content_tag = this.content_elem.tagName.toLowerCase();\r\n      if (!nrows) return;\r\n      if (ie && ie <= 9 && !opts.tag) {\r\n        opts.tag = frow(0).match(/<([^>\\s/]*)/)[1].toLowerCase();\r\n      }\r\n      var nchildren = this.content_elem.children.length;\r\n      if (!opts.tag) {\r\n        opts.tag = this.content_elem.children[0].tagName.toLowerCase();\r\n      }\r\n      if (nchildren <= 1) {\r\n        // what's the purpose of this ??? it may clear the html content ...\r\n        cache.data = this.html(frow(0) + frow(0) + frow(0));\r\n      }\r\n      this.getRowsHeight(nrows);\r\n    },\r\n    getRowsHeight: function (nrows) {\r\n      var opts = this.options,\r\n        prev_item_height = opts.item_height;\r\n      opts.cluster_height = 0;\r\n      if (!nrows) return;\r\n      var nodes = this.content_elem.children;\r\n      if (!nodes.length) return;\r\n      var node = nodes[Math.floor(nodes.length / 2)];\r\n      opts.item_height = node.offsetHeight;\r\n      // consider table's border-spacing\r\n      if (opts.tag == 'tr' && getStyle('borderCollapse', this.content_elem) != 'collapse')\r\n        opts.item_height += parseInt(getStyle('borderSpacing', this.content_elem), 10) || 0;\r\n      // consider margins (and margins collapsing)\r\n      if (opts.tag != 'tr') {\r\n        var marginTop = parseInt(getStyle('marginTop', node), 10) || 0;\r\n        var marginBottom = parseInt(getStyle('marginBottom', node), 10) || 0;\r\n        opts.item_height += Math.max(marginTop, marginBottom);\r\n      }\r\n      opts.block_height = opts.item_height * opts.rows_in_block;\r\n      opts.rows_in_cluster = opts.blocks_in_cluster * opts.rows_in_block;\r\n      opts.cluster_height = opts.blocks_in_cluster * opts.block_height;\r\n      return prev_item_height != opts.item_height;\r\n    },\r\n    // get current cluster number\r\n    getClusterNum: function () {\r\n      this.options.scroll_top = this.scroll_elem.scrollTop;\r\n      return Math.floor(this.options.scroll_top / (this.options.cluster_height - this.options.block_height)) || 0;\r\n    },\r\n    // generate empty row if no data provided\r\n    generateEmptyRow: function () {\r\n      var opts = this.options;\r\n      if (!opts.tag || !opts.show_no_data_row) return [];\r\n      var empty_row = document.createElement(opts.tag),\r\n        no_data_content = document.createTextNode(opts.no_data_text), td;\r\n      empty_row.className = opts.no_data_class;\r\n      if (opts.tag == 'tr') {\r\n        td = document.createElement('td');\r\n        // fixes #53\r\n        td.colSpan = 100;\r\n        td.appendChild(no_data_content);\r\n      }\r\n      empty_row.appendChild(td || no_data_content);\r\n      return [empty_row.outerHTML];\r\n    },\r\n    // generate cluster for current scroll position\r\n    generate: function (frow, nrows, cluster_num) {\r\n      var opts = this.options;\r\n      /*\r\n      if (nrows < opts.rows_in_block) {\r\n        return {\r\n          top_offset: 0,\r\n          bottom_offset: 0,\r\n          rows_above: 0,\r\n          rows: nrows ? frow : this.generateEmptyRow\r\n        }\r\n      }\r\n      */\r\n      var items_start = Math.max((opts.rows_in_cluster - opts.rows_in_block) * cluster_num, 0),\r\n        items_end = Math.min(items_start + opts.rows_in_cluster, nrows),\r\n        top_offset = Math.max(items_start * opts.item_height, 0),\r\n        bottom_offset = Math.max((nrows - items_end) * opts.item_height, 0),\r\n        this_cluster_rows = [],\r\n        rows_above = items_start;\r\n      if (top_offset < 1) {\r\n        rows_above++;\r\n      }\r\n      for (var i = items_start; i < items_end; i++) {\r\n        try {\r\n          this_cluster_rows.push(frow(i));\r\n        }\r\n        catch (err) {\r\n          this_cluster_rows.push(this.generateEmptyRow());\r\n        }\r\n      }\r\n      return {\r\n        top_offset: top_offset,\r\n        bottom_offset: bottom_offset,\r\n        rows_above: rows_above,\r\n        rows: this_cluster_rows\r\n      }\r\n    },\r\n    renderExtraTag: function (class_name, height) {\r\n      var tag = document.createElement(this.options.tag),\r\n        clusterize_prefix = 'clusterize-';\r\n      tag.className = [clusterize_prefix + 'extra-row', clusterize_prefix + class_name].join(' ');\r\n      height && (tag.style.height = height + 'px');\r\n      return tag.outerHTML;\r\n    },\r\n    // if necessary verify data changed and insert to DOM\r\n    insertToDOM: function (frow, nrows, cache) {\r\n      // explore row's height\r\n      if (!this.options.cluster_height) {\r\n        this.exploreEnvironment(frow, nrows, cache);\r\n      }\r\n      var data = this.generate(frow, nrows, this.getClusterNum()),\r\n        this_cluster_rows = data.rows.join(''),\r\n        this_cluster_content_changed = this.checkChanges('data', this_cluster_rows, cache),\r\n        top_offset_changed = this.checkChanges('top', data.top_offset, cache),\r\n        only_bottom_offset_changed = this.checkChanges('bottom', data.bottom_offset, cache),\r\n        callbacks = this.options.callbacks,\r\n        layout = [];\r\n\r\n      if (this_cluster_content_changed || top_offset_changed) {\r\n        if (data.top_offset) {\r\n          this.options.keep_parity && layout.push(this.renderExtraTag('keep-parity'));\r\n          layout.push(this.renderExtraTag('top-space', data.top_offset));\r\n        }\r\n        layout.push(this_cluster_rows);\r\n        data.bottom_offset && layout.push(this.renderExtraTag('bottom-space', data.bottom_offset));\r\n        callbacks.clusterWillChange && callbacks.clusterWillChange();\r\n        this.html(layout.join(''));\r\n        this.options.content_tag == 'ol' && this.content_elem.setAttribute('start', data.rows_above);\r\n        this.content_elem.style['counter-increment'] = 'clusterize-counter ' + (data.rows_above - 1);\r\n        callbacks.clusterChanged && callbacks.clusterChanged();\r\n      } else if (only_bottom_offset_changed) {\r\n        this.content_elem.lastChild.style.height = data.bottom_offset + 'px';\r\n      }\r\n    },\r\n    // unfortunately ie <= 9 does not allow to use innerHTML for table elements, so make a workaround\r\n    html: function (data) {\r\n      var content_elem = this.content_elem;\r\n      if (ie && ie <= 9 && this.options.tag == 'tr') {\r\n        var div = document.createElement('div'), last;\r\n        div.innerHTML = '<table><tbody>' + data + '</tbody></table>';\r\n        while ((last = content_elem.lastChild)) {\r\n          content_elem.removeChild(last);\r\n        }\r\n        var rows_nodes = this.getChildNodes(div.firstChild.firstChild);\r\n        while (rows_nodes.length) {\r\n          content_elem.appendChild(rows_nodes.shift());\r\n        }\r\n      } else {\r\n        content_elem.innerHTML = data;\r\n      }\r\n    },\r\n    getChildNodes: function (tag) {\r\n      var child_nodes = tag.children, nodes = [];\r\n      for (var i = 0, ii = child_nodes.length; i < ii; i++) {\r\n        nodes.push(child_nodes[i]);\r\n      }\r\n      return nodes;\r\n    },\r\n    checkChanges: function (type, value, cache) {\r\n      var changed = value != cache[type];\r\n      cache[type] = value;\r\n      return changed;\r\n    }\r\n  }\r\n\r\n// support functions\r\n  function on(evt, element, fnc) {\r\n    return element.addEventListener ? element.addEventListener(evt, fnc, false) : element.attachEvent(\"on\" + evt, fnc);\r\n  }\r\n\r\n  function off(evt, element, fnc) {\r\n    return element.removeEventListener ? element.removeEventListener(evt, fnc, false) : element.detachEvent(\"on\" + evt, fnc);\r\n  }\r\n\r\n  function isArray(arr) {\r\n    return Object.prototype.toString.call(arr) === '[object Array]';\r\n  }\r\n\r\n  function isFunction(fnc) {\r\n    //https://stackoverflow.com/a/7356528/1395973\r\n    return fnc && {}.toString.call(fnc) === '[object Function]';\r\n  }\r\n\r\n  function getStyle(prop, elem) {\r\n    return window.getComputedStyle ? window.getComputedStyle(elem)[prop] : elem.currentStyle[prop];\r\n  }\r\n\r\n  return Clusterize;\r\n}))\r\n;","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","/*\r\nreusable D3.js class for (LARGE) tables\r\n* efficient with large data thanks to https://clusterize.js.org/\r\n* filterable thanks to D3\r\n* sortable thanks to http://bl.ocks.org/AMDS/4a61497182b8fcb05906\r\n* and https://www.kryogenix.org/code/browser/sorttable/)\r\n\r\n@author  Philippe Guglielmetti https://github.com/goulu/\r\n */\r\n\r\nimport {Clusterize} from 'clusterize.js'\r\nimport * as d3 from 'd3'\r\n\r\nmodule.exports=class Table extends Clusterize {\r\n\r\n    constructor(element, height = 400) {\r\n        /* build DOM structure like this:\r\n            <table>\r\n                <thead>\r\n                <tr>\r\n                    <th>Headers</th>\r\n                </tr>\r\n                </thead>\r\n            </table>\r\n            <div id=\"scrollArea\" class=\"clusterize-scroll\">\r\n                <table>\r\n                    <tbody id=\"contentArea\" class=\"clusterize-content\">\r\n                    <tr class=\"clusterize-no-data\">\r\n                        <td>Loading data…</td>\r\n                    </tr>\r\n                    </tbody>\r\n                </table>\r\n            </div>\r\n         */\r\n        if (typeof(element)=='string') {\r\n            element=d3.select(element) \r\n        }\r\n\r\n        let thead = element.append(\"table\").append(\"thead\");\r\n        thead.insert(\"th\").append(\"tr\").text(\"Headers\");\r\n\r\n        let scroll = element.append(\"div\")\r\n            .attr(\"id\", uniqueId)\r\n            .style(\"max-height\", height + 'px')\r\n            .classed(\"clusterize-scroll\", true)\r\n            .on('scroll', (function () {\r\n                var prevScrollLeft = 0;\r\n                return function () {\r\n                    var scrollLeft = this.scrollLeft();\r\n                    if (scrollLeft == prevScrollLeft) return;\r\n                    prevScrollLeft = scrollLeft;\r\n                    this.thead.style('margin-left', -scrollLeft);\r\n                }\r\n            })\r\n            );\r\n\r\n        let rows = scroll.append(\"table\").append(\"tbody\")\r\n            .attr(\"id\", uniqueId)\r\n            .classed(\"clusterize-content\", true);\r\n\r\n        super({\r\n            // rows: [], // do not specify it here\r\n            scrollId: scroll.attr(\"id\"),\r\n            contentId: rows.attr(\"id\"),\r\n        });\r\n\r\n        this.element = element;\r\n        this.thead = thead;\r\n        this.scroll = scroll;\r\n        this.rows = element.select(\"tbody\");\r\n\r\n        this.format(function (v) {\r\n            return v;\r\n        });\r\n\r\n\r\n        this.rowid(function (d) {\r\n            // by default, rowid is row number in data\r\n            // not bad, but doens't survive a table.sort ...\r\n            return this.data().indexOf(d)\r\n        })\r\n\r\n        this.options.callbacks = {\r\n            clusterChanged: this.resize.bind(this)\r\n        };\r\n\r\n        window.addEventListener(\"resize\", this.resize.bind(this));\r\n\r\n        let tr = rows.append(\"tr\").classed(\"clusterize-no-data\", true);\r\n        tr.append(\"td\").text(\"Loading data...\");\r\n\r\n        this.__data__ = []; // don't call data() since it would clear any existing DOM table\r\n\r\n        this._filter = function (d, i) {\r\n            return true;\r\n        }\r\n\r\n        this._selected = new Set([]);\r\n        this.sortAscending = true;\r\n    }\r\n\r\n    format(f) {\r\n        this._format = f;\r\n        return this;\r\n    }\r\n\r\n    // config\r\n\r\n    header(cols) {\r\n        let table = this;\r\n        this.columns = cols;\r\n        this.thead.selectAll(\"th\")\r\n            .remove();\r\n        this.thead.selectAll(\"th\")\r\n            .data(this.columns)\r\n            .enter()\r\n            .append(\"th\")\r\n            .text(function (column) {\r\n                return column;\r\n            })\r\n            .on('click', function (d, i) {\r\n                table.sort(i, table.sortAscending);\r\n                table.sortAscending = !table.sortAscending; // for the next time\r\n            });\r\n        return this; // for chaining\r\n    }\r\n\r\n    sort(i, ascending = true, stable = false) {\r\n        // sort data by i-th column, ascending or descending\r\n        // optionally with stable sort algo (slower...)\r\n        let th = this.thead.selectAll('th');\r\n        th.classed('aes', false).classed('des', false);\r\n        d3.select(th[0][i]).classed('aes', !ascending).classed('des', ascending);\r\n        let data = this.data();\r\n        if (data.length == 0) {\r\n            return this; // for chaining\r\n        }\r\n\r\n        if (!isArray(data[0])) { // rows are dicts\r\n            i = this.columns[i]; // index by field\r\n        }\r\n\r\n        let ic = new Intl.Collator('en', { 'sensitivity': 'base' });\r\n\r\n        function f(x, y) {\r\n            // universal (?) comparison\r\n            try {\r\n                x = x[i]\r\n            }\r\n            catch (e) {\r\n                x = undefined;\r\n            }\r\n            try {\r\n                y = y[i]\r\n            }\r\n            catch (e) {\r\n                y = undefined;\r\n            }\r\n\r\n            if (x === y) {\r\n                return 0;\r\n            }\r\n            if (typeof x === 'string') {\r\n                return ic.compare(x, y);\r\n            }\r\n            else if (typeof t === 'number') {\r\n                return x - y;\r\n            }\r\n            else {\r\n                return x > y ? 1 : -1\r\n            }\r\n        }\r\n\r\n        if (!ascending) {\r\n            let ff = f;\r\n            f = function (x, y) {\r\n                return ff(y, x);\r\n            }\r\n        }\r\n        let performance = window.performance,\r\n            t0 = performance.now();\r\n        if (stable) {\r\n            shaker_sort(data, f);\r\n        } else {\r\n            data.sort(f);\r\n        }\r\n        this.draw();\r\n        let dt = Math.round(performance.now() - t0)\r\n        if (dt > 1000) {\r\n            console.log(\"table.sort took \" + dt + \" milliseconds.\")\r\n        }\r\n        return this; // for chaining\r\n    }\r\n\r\n    rowAsArray(row) {\r\n        // return row as the array of visible cells\r\n        if (!isArray(row)) { // suppose it's a dict\r\n            row = this.columns.map(function (d, i) {\r\n                return row[d]\r\n            })\r\n        }\r\n        return row;\r\n    }\r\n\r\n    rowAsString(d, sep = '\\u3000') {\r\n        // sep is a very unlikely char to minimize the risk of wrong positive when searching\r\n        return this.rowAsArray(d).map(this._format).join(sep);\r\n    }\r\n\r\n    findInRow(d, what) {\r\n        // what must be in lowercase for\r\n        return this.rowAsString(d).toLowerCase().indexOf(what)\r\n    }\r\n\r\n    filter(f) {\r\n        if (isFunction(f)) {\r\n            this._filter = f;\r\n            this.draw(); // apply filter\r\n            return this; // for chaining\r\n        }\r\n        // assume f is a selection of an input field\r\n        let table = this;\r\n\r\n        this.filter(function (d, i) {\r\n            // here, this is the input field, which is .bound\r\n            let s = this.property(\"value\"); // https://stackoverflow.com/a/31369759/1395973\r\n            if (s === '') return true;\r\n            return table.findInRow(d, s.toLowerCase()) !== -1\r\n        }.bind(f)) // bind to the input field\r\n\r\n        f.on(\"input\", function () { // set the update event of the input field\r\n            table.draw();\r\n        });\r\n        return this; // for chaining\r\n    }\r\n\r\n    rowid(d) {\r\n        // returns a unique id of row associated to data d\r\n        if (isFunction(d)) {\r\n            this._rowid = d;\r\n            return this; // for chaining\r\n        }\r\n\r\n        return this._rowid(d)\r\n    }\r\n\r\n    on(e, f) {\r\n        this.options.callbacks[e] = f.bind(this);\r\n        return this; // for chaining\r\n    }\r\n\r\n    // run\r\n    data(d) {\r\n        if (d === undefined) {\r\n            return this.__data__;\r\n        }\r\n        this.__data__ = d;\r\n        return this.draw();\r\n    }\r\n\r\n    draw() {\r\n        let table = this;\r\n        let d = this.data();\r\n        if (d.length === 0) return table;\r\n        d = d.filter(table._filter);\r\n        this.update(function (i) {\r\n            let row = table.rowAsArray(d[i]);\r\n            return '<tr '\r\n                + 'id=\"r' + table.rowid(d[i]) + '\" ' // way to find the data back for selection. id must start with non numeric\r\n                + ((i in table._selected)\r\n                    ? 'class=\"highlight\"'\r\n                    : '')  // no handier way to select a hidden row ...\r\n                + '>'\r\n                + row.map(function (cell) {\r\n                    return '<td>' + (cell === undefined ? '' : table._format(cell)) + '</td>';\r\n                }).join('')\r\n                + '</tr>'\r\n        }\r\n            ,\r\n            d.length\r\n        );\r\n\r\n        table.resize(); // redraw\r\n        return table;\r\n    }\r\n\r\n    // events\r\n\r\n    resize() {\r\n        let table = this;\r\n        // Makes header columns equal width to content columns\r\n        let scrollBarWidth = width(this.element)[0] - width(this.rows)[0],\r\n            td = this.rows.select('tr:not(.clusterize-extra-row)').selectAll('td'),\r\n            w = width(td);\r\n        w[w.length - 1] += scrollBarWidth;\r\n        width(this.thead.selectAll('th'), w);\r\n\r\n        // (re)attach events to rows\r\n\r\n        function fevent() {\r\n            let e = d3.event;\r\n            if (e.type in table.options.callbacks) { // handle it\r\n                let target = e.target;\r\n                if (target.tagName == 'TD') {\r\n                    target = target.parentElement; // events are on rows (for now)\r\n                }\r\n                // retrieve the data (TODO: there should be a quicker way...)\r\n                let i = target.id.substr(1),  //get tr #id\r\n                    d = table.data().find(function (d) {\r\n                        return table.rowid(d) == i\r\n                    });\r\n                return table.options.callbacks[e.type](d, i);\r\n            }\r\n        }\r\n\r\n        this.rows.selectAll(\"tr\")\r\n            .on(\"mouseover\", fevent)\r\n            .on(\"mouseleave\", fevent)\r\n            .on(\"click\", fevent)\r\n            .on(\"dblclick\", fevent)\r\n            .classed(\"highlight\", function (d, i) {\r\n                return table._selected.has(i);\r\n            })\r\n\r\n        return table;\r\n    }\r\n\r\n    add(newdata, i = -1) {\r\n        // merge and sort data with current\r\n        // don't rename it \"append\" to avoid conflicts with Clusterize and/or D3\r\n        this.__data__ = this.data().concat(newdata);\r\n        if (i >= 0) {\r\n            this.sort(i);\r\n        } else {\r\n            this.draw();\r\n        }\r\n        return this.data();\r\n    }\r\n\r\n\r\n    scrollTo(d, ms = 1000) {\r\n        // smooth scroll to data d in ms milliseconds\r\n        let table = this,\r\n            length = this.data().filter(this._filter).length,\r\n            node = this.scroll.node(),\r\n            f = node.scrollHeight / length,\r\n            nlines = node.clientHeight / f,\r\n            line = this.findIndex(d);\r\n\r\n        function scrollTween(offset) {\r\n            return function () {\r\n                let i = d3.interpolateNumber(node.scrollTop, offset);\r\n                return function (t) {\r\n                    node.scrollTop = i(t);\r\n                };\r\n            };\r\n        }\r\n\r\n        this.rows.transition()\r\n            .duration(ms)\r\n            .each(\"end\", function () {\r\n                table.select();\r\n            }\r\n            )\r\n            .tween(\"scroll\", scrollTween(\r\n                (line - Math.round(nlines / 2)) * f\r\n            )\r\n            )\r\n            ;\r\n        return this; // for chaining\r\n    }\r\n\r\n    indexOf(d) {\r\n        return this.data().filter(this._filter).indexOf(d);\r\n    }\r\n\r\n    find(d) {\r\n        let table = this,\r\n            id = table.rowid(d);\r\n        return this.data().filter(this._filter).find(\r\n            function (e) {\r\n                return table.rowid(e) === id;\r\n            }\r\n        )\r\n    }\r\n    findIndex(d) {\r\n        let table = this,\r\n            id = table.rowid(d);\r\n        return this.data().filter(this._filter).findIndex(\r\n            function (e) {\r\n                return table.rowid(e) === id;\r\n            }\r\n        )\r\n    }\r\n\r\n\r\n    select(d, i) {\r\n        let table = this;\r\n\r\n        function highlight(i) {\r\n            table._selected.add(i);\r\n            let tr = table.rows.select(\"#r\" + i);\r\n            tr.classed(\"highlight\", true);\r\n        }\r\n\r\n        if (i === undefined) {\r\n            if (d === undefined) {\r\n                this._selected.forEach(highlight);\r\n                return this\r\n            }\r\n            i = this.rowid(d)\r\n        }\r\n\r\n        highlight(i);\r\n\r\n        return this; // for chaining\r\n    }\r\n\r\n    deselect(d, i) {\r\n        if (i === undefined) {\r\n            if (d === undefined) {\r\n                this._selected.clear();\r\n                this.draw();\r\n                return this\r\n            }\r\n            i = this.rowid(d)\r\n        }\r\n        this._selected.delete(i);\r\n        let tr = this.rows.select(\"#r\" + i);\r\n        tr.classed(\"highlight\", false);\r\n        return this; // for chaining\r\n    }\r\n}\r\n\r\n\r\n// first and last of a selection\r\n// https://stackoverflow.com/a/25413534/1395973\r\nd3\r\n    .selection\r\n    .prototype\r\n    .first = function () {\r\n        return d3.select(this[0][0]);\r\n    };\r\nd3\r\n    .selection\r\n    .prototype\r\n    .last = function () {\r\n        var last = this.size() - 1;\r\n        return d3.select(this[0][last]);\r\n    };\r\n\r\n// utility functions\r\n\r\nfunction width(sel, value) {\r\n    // mimics jQuery for D3 https://api.jquery.com/category/dimensions/\r\n    if (value === undefined) { // get\r\n        let w = [];\r\n        sel.each(function (d) {\r\n            w.push(this.getBoundingClientRect().width);\r\n        });\r\n        return w;\r\n    }\r\n    else { // set\r\n        sel.style(\"width\", function (d, i) {\r\n            let w = value[i];\r\n            return w + \"px\";\r\n        });\r\n    }\r\n\r\n    return sel; // for chaining\r\n}\r\n\r\n\r\nfunction uniqueId() {\r\n    // https://gist.github.com/gordonbrander/2230317\r\n    // Math.random should be unique because of its seeding algorithm.\r\n    // Convert it to base 36 (numbers + letters), and grab the first 9 characters\r\n    // after the decimal.\r\n    return \"_\" + Math.random().toString(36).substr(2, 9);\r\n}\r\n\r\nfunction shaker_sort(list, comp_func) {\r\n    // A stable sort function to allow multi-level sorting of data\r\n    // see: http://en.wikipedia.org/wiki/Cocktail_sort\r\n    // thanks to Joseph Nahmias\r\n    let b = 0;\r\n    let t = list.length - 1;\r\n    let swap = true;\r\n\r\n    while (swap) {\r\n        swap = false;\r\n        for (var i = b; i < t; ++i) {\r\n            if (comp_func(list[i], list[i + 1]) > 0) {\r\n                let q = list[i];\r\n                list[i] = list[i + 1];\r\n                list[i + 1] = q;\r\n                swap = true;\r\n            }\r\n        } // for\r\n        t--;\r\n\r\n        if (!swap) break;\r\n\r\n        for (var i = t; i > b; --i) {\r\n            if (comp_func(list[i], list[i - 1]) < 0) {\r\n                let q = list[i];\r\n                list[i] = list[i - 1];\r\n                list[i - 1] = q;\r\n                swap = true;\r\n            }\r\n        } // for\r\n        b++;\r\n\r\n    } // while(swap)\r\n    return list;\r\n}\r\n\r\nfunction isFunction(fnc) {\r\n    //https://stackoverflow.com/a/7356528/1395973\r\n    return fnc && {}.toString.call(fnc) === '[object Function]';\r\n}\r\n\r\nfunction isArray(arr) {\r\n    return Object.prototype.toString.call(arr) === '[object Array]';\r\n}\r\n\r\nfunction dictValues(d) {\r\n    return Object.keys(d).map(function (key) {\r\n        return d[key];\r\n    })\r\n}","module.exports = d3;"],"sourceRoot":""}